[[modules-scripting]]
== Scripting

The scripting module enables you to use scripts to evaluate custom
expressions. For example, you could use a script to return "script fields"
as part of a search request or evaluate a custom score for a query.

TIP: Elasticsearch now has a built-in scripting language called _Painless_
that provides a more secure alternative for implementing
scripts for Elasticsearch. We encourage you to try it out--
for more information, see <<modules-scripting-painless, Painless Scripting Language>>.

The default scripting language is http://groovy-lang.org/[groovy] 

Additional `lang` plugins enable you to run scripts written in other languages. 
Everywhere a script can be used, you can include a `lang` parameter
to specify the language of the script.

General-purpose languages:

These languages can be used for any purpose in the scripting APIs,
and give the most flexibility. 

[cols="<,<,<",options="header",]
|=======================================================================
|Language   |Sandboxed |Required plugin
|<<modules-scripting-painless, painless>>   |yes       |built-in
|<<modules-scripting-groovy, groovy>>       |<<modules-scripting-security, no>>        |built-in
|{plugins}/lang-javascript.html[javascript] |<<modules-scripting-security, no>>        |{plugins}/lang-javascript.html[lang-javascript]
|{plugins}/lang-python.html[python]         |<<modules-scripting-security, no>>        |{plugins}/lang-python.html[lang-python]
|=======================================================================

Special-purpose languages:

These languages are less flexible, but typically have higher performance for
certain tasks.

[cols="<,<,<,<",options="header",]
|=======================================================================
|Language   |Sandboxed |Required plugin |Purpose
|<<modules-scripting-expression, expression>> |yes       |built-in      |fast custom ranking and sorting
|<<search-template, mustache>>                |yes       |built-in      |templates
|<<modules-scripting-native, java>>           |n/a       |you write it! |expert API
|=======================================================================

[float]
=== Scripts and security

Languages that are sandboxed are designed with security in mind. However, non-sandboxed
languages can be a security issue, please read <<modules-scripting-security, Scripting and security>>
for more details.

[float]
=== File-based Scripts

To increase security, Elasticsearch does not allow you to specify scripts for
non-sandboxed languages with a request. Instead, scripts must be placed in the
`scripts` directory inside the configuration directory (the directory where
elasticsearch.yml is). The default location of this `scripts` directory can be
changed by setting `path.scripts` in elasticsearch.yml. Scripts placed into
this directory will automatically be picked up and be available to be used.
Once a script has been placed in this directory, it can be referenced by name.
For example, a script called `calculate-score.groovy` can be referenced in a
request like this:

[source,sh]
--------------------------------------------------
$ tree config
config
├── elasticsearch.yml
├── logging.yml
└── scripts
    └── calculate-score.groovy
--------------------------------------------------

[source,sh]
--------------------------------------------------
$ cat config/scripts/calculate-score.groovy
log(_score * 2) + my_modifier
--------------------------------------------------

[source,js]
--------------------------------------------------
curl -XPOST localhost:9200/_search -d '{
  "query": {
    "function_score": {
      "query": {
        "match": {
          "body": "foo"
        }
      },
      "functions": [
        {
          "script_score": {
            "script": {
              "lang": "groovy",
              "file": "calculate-score",
              "params": {
                "my_modifier": 8
              }
            }
          }
        }
      ]
    }
  }
}'
--------------------------------------------------

The name of the script is derived from the hierarchy of directories it
exists under, and the file name without the lang extension. For example,
a script placed under `config/scripts/group1/group2/test.py` will be
named `group1_group2_test`.

[float]
[[modules-scripting-stored-scripts]]
=== Stored Scripts
Elasticsearch allows you to store scripts in the cluster state.
There are REST endpoints to manage stored scripts as follows:

Requests to the scripts endpoint look like :
[source,js]
-----------------------------------
/_scripts/{lang}/{id}
-----------------------------------
Where the `lang` part is the language the script is in and the `id` part is the id
of the script.

[source,js]
-----------------------------------
curl -XPOST localhost:9200/_scripts/groovy/calculateScore -d '{
     "script": "log(_score * 2) + my_modifier"
}'
-----------------------------------

This will store the script under the `calculateScore` in the cluster
state.

This script can be accessed at query time by using the `id` and `lang` script parameters:

[source,js]
--------------------------------------------------
curl -XPOST localhost:9200/_search -d '{
  "query": {
    "function_score": {
      "query": {
        "match": {
          "body": "foo"
        }
      },
      "functions": [
        {
          "script_score": {
            "script": {
              "id": "calculateScore",
              "lang" : "groovy",
              "params": {
                "my_modifier": 8
              }
            }
          }
        }
      ]
    }
  }
}'
--------------------------------------------------

The script can be viewed by:
[source,js]
-----------------------------------
curl -XGET localhost:9200/_scripts/groovy/calculateScore
-----------------------------------

This is rendered as:

[source,js]
-----------------------------------
'{
     "script": "log(_score * 2) + my_modifier"
}'
-----------------------------------

Stored scripts can be deleted by:
[source,js]
-----------------------------------
curl -XDELETE localhost:9200/_scripts/groovy/calculateScore
-----------------------------------

NOTE: The size of stored scripts is limited to 65535 bytes. This can be changed by setting `script.max_size_in_bytes`
setting to increase that soft limit, but if scripts are really large then alternatives like native scripts should be considered.

[float]
=== Default Scripting Language

The default scripting language (assuming no `lang` parameter is provided) is
`groovy`. In order to change it, set the `script.default_lang` to the
appropriate language.

[float]
=== Automatic Script Reloading

The `config/scripts` directory is scanned periodically for changes.
New and changed scripts are reloaded and deleted script are removed
from preloaded scripts cache. The reload frequency can be specified
using `resource.reload.interval` setting, which defaults to `60s`.
To disable script reloading completely set `script.auto_reload_enabled`
to `false`.

[float]
=== Score

In all scripts that can be used in aggregations, the current
document's score is accessible in `_score`.

[float]
=== Computing scores based on terms in scripts

see <<modules-advanced-scripting, advanced scripting documentation>>

[float]
=== Document Fields

Most scripting revolve around the use of specific document fields data.
The `doc['field_name']` can be used to access specific field data within
a document (the document in question is usually derived by the context
the script is used). Document fields are very fast to access since they
end up being loaded into memory (all the relevant field values/tokens
are loaded to memory). Note, however, that the `doc[...]` notation only
allows for simple valued fields (can’t return a json object from it)
and makes sense only on non-analyzed or single term based fields.

The following data can be extracted from a field:

[cols="<,<",options="header",]
|=======================================================================
|Expression |Description
|`doc['field_name'].value` |The native value of the field. For example,
if its a short type, it will be short.

|`doc['field_name'].values` |The native array values of the field. For
example, if its a short type, it will be short[]. Remember, a field can
have several values within a single doc. Returns an empty array if the
field has no values.

|`doc['field_name'].empty` |A boolean indicating if the field has no
values within the doc.

|`doc['field_name'].multiValued` |A boolean indicating that the field
has several values within the corpus.

|`doc['field_name'].lat` |The latitude of a geo point type.

|`doc['field_name'].lon` |The longitude of a geo point type.

|`doc['field_name'].lats` |The latitudes of a geo point type.

|`doc['field_name'].lons` |The longitudes of a geo point type.

|`doc['field_name'].distance(lat, lon)` |The `plane` distance (in meters)
of this geo point field from the provided lat/lon.

|`doc['field_name'].distanceWithDefault(lat, lon, default)` |The `plane` distance (in meters)
of this geo point field from the provided lat/lon with a default value.

|`doc['field_name'].distanceInMiles(lat, lon)` |The `plane` distance (in
miles) of this geo point field from the provided lat/lon.

|`doc['field_name'].distanceInMilesWithDefault(lat, lon, default)` |The `plane` distance (in
miles) of this geo point field from the provided lat/lon with a default value.

|`doc['field_name'].distanceInKm(lat, lon)` |The `plane` distance (in
km) of this geo point field from the provided lat/lon.

|`doc['field_name'].distanceInKmWithDefault(lat, lon, default)` |The `plane` distance (in
km) of this geo point field from the provided lat/lon with a default value.

|`doc['field_name'].arcDistance(lat, lon)` |The `arc` distance (in
meters) of this geo point field from the provided lat/lon.

|`doc['field_name'].arcDistanceWithDefault(lat, lon, default)` |The `arc` distance (in
meters) of this geo point field from the provided lat/lon with a default value.

|`doc['field_name'].arcDistanceInMiles(lat, lon)` |The `arc` distance (in
miles) of this geo point field from the provided lat/lon.

|`doc['field_name'].arcDistanceInMilesWithDefault(lat, lon, default)` |The `arc` distance (in
miles) of this geo point field from the provided lat/lon with a default value.

|`doc['field_name'].arcDistanceInKm(lat, lon)` |The `arc` distance (in
km) of this geo point field from the provided lat/lon.

|`doc['field_name'].arcDistanceInKmWithDefault(lat, lon, default)` |The `arc` distance (in
km) of this geo point field from the provided lat/lon with a default value.

|`doc['field_name'].factorDistance(lat, lon)` |The distance factor of this geo point field from the provided lat/lon.

|`doc['field_name'].factorDistance(lat, lon, default)` |The distance factor of this geo point field from the provided lat/lon with a default value.

|`doc['field_name'].geohashDistance(geohash)` |The `arc` distance (in meters)
of this geo point field from the provided geohash.

|`doc['field_name'].geohashDistanceInKm(geohash)` |The `arc` distance (in km)
of this geo point field from the provided geohash.

|`doc['field_name'].geohashDistanceInMiles(geohash)` |The `arc` distance (in
miles) of this geo point field from the provided geohash.
|=======================================================================

[float]
=== Stored Fields

Stored fields can also be accessed when executing a script. Note, they
are much slower to access compared with document fields, as they are not
loaded into memory. They can be simply accessed using
`_fields['my_field_name'].value` or `_fields['my_field_name'].values`.

[float]
=== Accessing the score of a document within a script

When using scripting for calculating the score of a document (for instance, with
the `function_score` query), you can access the score using the `_score`
variable inside of a Groovy script.

[float]
=== Source Field

The source field can also be accessed when executing a script. The
source field is loaded per doc, parsed, and then provided to the script
for evaluation. The `_source` forms the context under which the source
field can be accessed, for example `_source.obj2.obj1.field3`.

Accessing `_source` is much slower compared to using `doc`
but the data is not loaded into memory. For a single field access `_fields` may be
faster than using `_source` due to the extra overhead of potentially parsing large documents.
However, `_source` may be faster if you access multiple fields or if the source has already been
loaded for other purposes.

